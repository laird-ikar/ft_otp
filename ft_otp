#!python3

import sys
import os
import re
import qrcode
import time
import rsa
from hashlib import sha1
import random
from PIL import Image
import base64
import warnings

def generate_RSA_keys():
    (publicKey, privateKey) = rsa.newkeys(1024)
    with open('./rsa_keys/publicKey.pem', 'wb') as p:
        p.write(publicKey.save_pkcs1('PEM'))
    with open('./rsa_keys/privateKey.pem', 'wb') as p:
        p.write(privateKey.save_pkcs1('PEM'))

def load_RSA_keys():
    with open('./rsa_keys/publicKey.pem', 'rb') as p:
        publicKey = rsa.PublicKey.load_pkcs1(p.read())
    with open('./rsa_keys/privateKey.pem', 'rb') as p:
        privateKey = rsa.PrivateKey.load_pkcs1(p.read())
    return privateKey, publicKey

def qrcode_creation(seed):
	rand = random.Random(seed)
	data = rand.randbytes(64).hex()#.to_bytes(32, sys.byteorder).hex() #rand.randbytes -> rand.getrandbits parce que apparemment la fonction randbytes a disparu depuis la derniere fois 

	# Generate QR code
	qr = qrcode.QRCode(
		version=1,
		error_correction=qrcode.constants.ERROR_CORRECT_H,
		box_size=10,
		border=4
	)
	qr.add_data(data, optimize=0) #optimize=0 sinon ca crash, va savoir pq
	qr.make(fit=True)

	qr_image = qr.make_image(fill_color="black", back_color="white")
	# Load the overlay image
	overlay_image = Image.open("overlay_image.png")

	# Load the overlay image with transparency intact
	overlay_image = Image.open("overlay_image.png").convert("RGBA")

    # Calculate the desired size of the overlay image
	desired_size = (qr_image.size[0] // 3, qr_image.size[1] // 3)

    # Resize the overlay image while maintaining its aspect ratio
	with warnings.catch_warnings():
		warnings.filterwarnings("ignore", category=DeprecationWarning)  # Filter out the Antialias deprecation warning
		overlay_image.thumbnail(desired_size, Image.ANTIALIAS)

    # Calculate the position to center the overlay image on the QR code
	position = ((qr_image.size[0] - overlay_image.size[0]) // 2, (qr_image.size[1] - overlay_image.size[1]) // 2)

    # Create a composite image by pasting the overlay image onto the QR code at the calculated position
	final_image = Image.new("RGBA", qr_image.size)
	final_image.paste(qr_image, (0, 0))
	final_image.paste(overlay_image, position, overlay_image)

    # Save the final image
	final_image.save("qr_code.png")
	os.system("open qr_code.png")


def encode(key) -> str:
	if not os.path.isdir('./rsa_keys'):
		os.mkdir('./rsa_keys')
		generate_RSA_keys()
	keys = load_RSA_keys()
	return rsa.encrypt(key.encode('ascii'), keys[1])

def decode(cipher) -> int:
	keys = load_RSA_keys()
	return int(rsa.decrypt(cipher, keys[0]).decode('ascii'), 16)

def generate_key(keyfile):
	if not os.path.isfile(keyfile):
		print("Keyfile does not exist .⁠·⁠´⁠¯⁠⁠(⁠>⁠▂⁠<⁠)⁠´⁠¯⁠⁠·⁠.")
		exit(1)
	with open(keyfile, "r") as file:
		key = file.read()
	if (len(key) < 64):
		print("(⁠ノ⁠•̀⁠ ⁠o⁠ ⁠•́⁠ ⁠)⁠ノ⁠ ⁠~⁠ ⁠┻⁠━⁠┻ Keyfile must be at least 64 characters long")
		exit(1)
	key = key.lower()
	if not re.match("^[0-9a-f]+$", key):
		print("Keyfile must only contain hexadecimal characters (⁠●⁠´⁠⌓⁠`⁠●⁠)")
		exit(1)
	with open ("ft_otp.key", "wb+") as fkey:
		fkey.write(encode(key))

def generate_tmp_password(keyfile):
	if not os.path.isfile(keyfile):
		print("Keyfile does not exist .⁠·⁠´⁠¯⁠⁠(⁠>⁠▂⁠<⁠)⁠´⁠¯⁠⁠·⁠.")
		exit(1)
	with open(keyfile, "rb") as file:
		key = file.read()
	key = decode(key)
	time_count = int(time.time() // 30)
	hs = hmac_sha1(key, time_count)
	sbits = dt(hs)
	snum = Saint_Ton_Nhum(sbits)
	tmp_passwd = snum % 10 ** 6
	print(f"(⁠☞⁠ ⁠ಠ⁠_⁠ಠ⁠)⁠☞ Take this bg -> {tmp_passwd:06}")
	qrcode_creation(tmp_passwd)

def hmac_sha1(key:int, count:int) -> bytes: # 💯 no bug, checked against python hmac
	key = [n for n in key.to_bytes(32, 'little')]

	i_key_pad = [k ^ 0x36 for k in key]
	o_key_pad = [k ^ 0x5c for k in key]

	hs = sha1(
		bytes(o_key_pad) +
		sha1(bytes(i_key_pad) +
			count.to_bytes(32, 'big')
		).digest()).digest()
	return hs

#takes a hs as argument, and executes dt on it
def dt(hs:bytes) -> bytes: # fuck seems legit (⁠ノ⁠•̀⁠ ⁠o⁠ ⁠•́⁠ ⁠)⁠ノ⁠ ⁠~⁠ ⁠┻⁠━⁠┻
	offset = hs[-1] & 0xf
	bincode = (hs[offset]  & 0x7f) << 24 | (hs[offset+1] & 0xff) << 16 | (
		hs[offset+2] & 0xff) <<  8 | (hs[offset+3] & 0xff)
	return bincode

def Saint_Ton_Nhum(sbits):
	return sbits

# MAIN ##
def main():
	if len(sys.argv) != 3 or (sys.argv[1] != "-g" and sys.argv[1] != "-k"):
		print("Usage:\n\t./ft_otp -g keyfile\n\t./ft_otp -k keyfile")
		exit(1)
	if sys.argv[1] == "-g":
		generate_key(sys.argv[2])
		print("  .・。.・✭゜・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・")
		print("✧･ﾟYour key was successfully and gracefully generated in your beloved ft_otp.key file, my dear ﾟ･✧")
		print("  .・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜")
	elif sys.argv[1] == "-k":
		generate_tmp_password(sys.argv[2])

if __name__ == "__main__":
	main()