#!python3

import sys
import os
import re
import qrcode
import time
import rsa
from hashlib import sha1
import random
import hmac

def generate_RSA_keys():
    (publicKey, privateKey) = rsa.newkeys(1024)
    with open('./rsa_keys/publicKey.pem', 'wb') as p:
        p.write(publicKey.save_pkcs1('PEM'))
    with open('./rsa_keys/privateKey.pem', 'wb') as p:
        p.write(privateKey.save_pkcs1('PEM'))

def load_RSA_keys():
    with open('./rsa_keys/publicKey.pem', 'rb') as p:
        publicKey = rsa.PublicKey.load_pkcs1(p.read())
    with open('./rsa_keys/privateKey.pem', 'rb') as p:
        privateKey = rsa.PrivateKey.load_pkcs1(p.read())
    return privateKey, publicKey


def qrcode_creation(seed):
	rand = random.Random(seed)
	data = rand.getrandbits(32).to_bytes(32, sys.byteorder).hex() #rand.randbytes -> rand.getrandbits parce que apparemment la fonction randbytes a disparu depuis la derniere fois 

	# Generate QR code
	qr = qrcode.QRCode(
		version=1,
		error_correction=qrcode.constants.ERROR_CORRECT_H,
		box_size=10,
		border=4
	)
	qr.add_data(data, optimize=0) #optimize=0 sinon ca crash, va savoir pq
	qr.make(fit=True)

	qr_image = qr.make_image(fill_color="black", back_color="white")
	qr_image.save("qr_code.png")
	os.system("open qr_code.png")

def encode(key) -> str:
	if not os.path.isdir('./rsa_keys'):
		os.mkdir('./rsa_keys')
		generate_RSA_keys()
	keys = load_RSA_keys()
	return rsa.encrypt(key.encode('ascii'), keys[1])


def decode(cipher) -> int:
	keys = load_RSA_keys()
	return int(rsa.decrypt(cipher, keys[0]).decode('ascii'), 16)

def generate_key(keyfile):
	if not os.path.isfile(keyfile):
		print("Keyfile does not exist .⁠·⁠´⁠¯⁠⁠(⁠>⁠▂⁠<⁠)⁠´⁠¯⁠⁠·⁠.")
		exit(1)
	with open(keyfile, "r") as file:
		key = file.read()
	if (len(key) < 64):
		print("(⁠ノ⁠•̀⁠ ⁠o⁠ ⁠•́⁠ ⁠)⁠ノ⁠ ⁠~⁠ ⁠┻⁠━⁠┻ Keyfile must be at least 64 characters long")
		exit(1)
	key = key.lower()
	if not re.match("^[0-9a-f]+$", key):
		print("Keyfile must only contain hexadecimal characters (⁠●⁠´⁠⌓⁠`⁠●⁠)")
		exit(1)
	with open ("ft_otp.key", "wb+") as fkey:
		fkey.write(encode(key))

def generate_tmp_password(keyfile):
	if not os.path.isfile(keyfile):
		print("Keyfile does not exist .⁠·⁠´⁠¯⁠⁠(⁠>⁠▂⁠<⁠)⁠´⁠¯⁠⁠·⁠.")
		exit(1)
	with open(keyfile, "rb") as file:
		key = file.read()
	key = decode(key)
	print(key)
	time_count = int(time.time() // 30)
	time_count = 0
	hs = hmac_sha1(key, time_count)
	sbits = dt(hs)
	snum = Saint_Ton_Nhum(sbits)
	tmp_passwd = snum % 10 ** 6
	print(f"(⁠☞⁠ ⁠ಠ⁠_⁠ಠ⁠)⁠☞ Take this bg -> {tmp_passwd:06}")
	qrcode_creation(tmp_passwd)

def hmac_sha1(key:int, count:int) -> bytes:
	key = [n for n in key.to_bytes(64, sys.byteorder)]

	i_key_pad = [k ^ 0x36 for k in key]
	o_key_pad = [k ^ 0x5c for k in key]

	hs = sha1(
		bytes(o_key_pad) +
		sha1(bytes(i_key_pad) +
			count.to_bytes(64, 'little')
		).digest()).digest()

	return hs

#takes a hs as argument, and executes dt on it
def dt(hs:bytes) -> bytes:
	offset = hs[-1] & 0xf
	bincode = (hs[offset] & 0x7f) << 24
	bincode |= (hs[offset + 1] & 0xff) << 16
	bincode |= (hs[offset + 2] & 0xff) << 8
	bincode |= (hs[offset + 3] & 0xff)
	return hs

def Saint_Ton_Nhum(sbits):
	return int.from_bytes(sbits, sys.byteorder)

# MAIN ##
def main():
	if len(sys.argv) != 3 or (sys.argv[1] != "-g" and sys.argv[1] != "-k"):
		print("Usage:\n\t./ft_otp -g keyfile\n\t./ft_otp -k keyfile")
		exit(1)
	if sys.argv[1] == "-g":
		generate_key(sys.argv[2])
		print("  .・。.・✭゜・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。.  ")
		print("✧･ﾟYour key was successfully and gracefully generated in your beloved ft_otp.key file, my dear ﾟ･✧")
		print("  .・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。. .・。.・゜✭・.・✫・゜・。..・。  ")
	elif sys.argv[1] == "-k":
		generate_tmp_password(sys.argv[2])

if __name__ == "__main__":
	main()